---
title:  "[Algorithm] Maximum Flow & Max-flow Min-cut"
excerpt: "Maximum Flow & Max-flow Min-cut Theorem"

categories:
  - Algorithm
tags:
  - Algorithm
last_modified_at: 2025-04-18T08:06:00-05:00
---

# Maximum Flow
최대 유량 문제(Maximum Flow)는 방향 그래프에서 각 간선의 용량이 정해져 있을 때, 정해진 출발점(source)에서 도착점(sink)까지 보낼 수 있는 최대의 유량을 계산하는 문제이다. 

유량 그래프(Flow Network)와 유량 그래프에서 흐르는 유량(Flow)의 예시는 다음과 같다. 

<p align="center"><img src="https://github.com/user-attachments/assets/50e642a3-7766-45c6-b2fc-444b97d77f20" height="" width=""></p>

유한 그래프는 무한한 양의 물이 흘러들어오는 정점 s(source)와 무한한 양의 물을 받아낼 수 있는 정점 t(sink)가 있고 각 파이프에는 물이 흐르는 방향과 흘릴 수 있는 용량이 정해져 있다. 간선에 적힌 a/b에서 b가 용량, a가 현재 유량이다. 

위 그림의 경우 $s \to a \to b \to t$경로로 2, $s \to a \to t$경로로 1, $s \to e \to t$경로로 4, $s \to c \to d \to t$경로로 4의 유량이 흐르며 총 유량이 11이다. 최소 1의 유량이 흐를 수 있는 source에서 sink로의 경로를 증가 경로(Augmented Path)라고 하는데, 위 그림에서는 더 이상의 증가 경로가 없다. 

## Residual Graph

포드-풀커슨 알고리즘은 증가 경로가 나오지 않을 때까지 유량을 greedy 방법으로 흘려주는 방식이다. 

<p align="center"><img src="https://github.com/user-attachments/assets/bd2d7171-4b57-47bf-a724-ea5930ddb17b" height="" width="">

초기 그래프에서 DFS를 적용하여 증가 경로 $s \to a \to e \to t$를 찾았다고 하자. 간선 $s \to a$는 3, 간선 $a \to e$는 5, 간선 $e \to t$는 4의 용량을 가지고 있으므로, 이 증가 경로를 통해서는 최솟값인 3의 유량이 최대로 흐를 수 있다. 

<p align="center"><img src="https://github.com/user-attachments/assets/547be556-f69a-46e1-8f71-a5cda0319503" height="" width="">

간선 $s \to a$의 유량이 최대가 되었으므로 증가 경로는 더 이상 간선 $s \to a$를 포함할 수 없다. 이후 간선 $s \to c$을 사용하는 증가 경로인 $s \to c \to d \to t$를 찾았고 최대 유량인 4를 흘려주었다. 

<p align="center"><img src="https://github.com/user-attachments/assets/f1558549-355f-448d-9722-c32f66e06b41" height="" width="">

마지막으로 간선 $s \to e$를 포함하는 증가 경로인 $s \to e \to t$를 찾았고, $e \to t$에 이미 유량 3이 흐르고 있으므로 최대 1까지만 더 흘려줄 수 있다. 

이렇게 구한 증가 경로들의 총 유량은 8인데 앞서 보았듯이 최대 유량은 11이다. greedy 방법대로 증가 경로를 찾았지만 최대 유량을 찾지 못했는데 이를 해결하기 위해 잔여 그래프(Residual Graph)가 사용된다. 

잔여 그래프는 유량 그래프에서 이미 어떠한 유량이 흐른 뒤, 앞으로 더 흘릴 수 있는 남은 용량만 고려해서 만든 그래프로, 실제로는 남은 용량만 고려하지 않고, 기존의 간선과 반대 방향인 가상의 간선을 추가한다. 만약 기존의 간선에 유량 n이 흐르고 있었다면, 반대 방향의 간선으로 유량 -n이 흐른다고 판단하며, 이렇게 하여 반대 방향의 간선에 n만큼의 여유 용량이 생기므로 해당 간선에 유량을 흘려 줄 수 있다. 

<p align="center"><img src="https://github.com/user-attachments/assets/794cb5e2-ee1b-4054-9c84-5d15a9a30428" height="" width="">

왼쪽이 기존의 유량 그래프라면, 잔여 그래프는 오른쪽과 같다. 
a에서 b로 가는 파이프의 용량이 C이고 그 중 이미 F만큼 흐르고 있다고 하면, a에서 b로 가는 파이프는 아직 C-F만큼의 용량이 남았으니 이를 잔여 그래프로 만든다. 또한 b에서 a로 가는 가상의 파이프를 만들고 a에서 b로 C만큼 흐른다고 하면, 반대 방향으로 -C만큼 유량이 흐른다 판단하여 b에서 a로 가상의 파이프를 통해 C만큼의 유량을 흘려줄 수 있다. 

잔여 그래프를 통해 반대 방향의 간선에 유량을 흘릴 수 있다는 것은 기존 간선에 있던 유량을 취소하고 우회한다는 것과 같은 의미이다. 따라서 앞서 greedy 방법을 사용했을 때 해결되지 않은 최대 유량이 반대 방향의 간선을 설정해 줌으로써 해결할 수 있다. 이것이 포드-풀커슨 알고리즘의 가장 중요한 부분이다. 

<p align="center"><img src="https://github.com/user-attachments/assets/d805597b-be68-4d41-a323-43a4f06a90a0" height="" width="">

포드-풀커슨 알고리즘의 시간 복잡도를 따지기 위해 위 예시를 들어보면 DFS로 경로를 찾을 때 $s \to a \to b \to t$를 먼저 찾는다. 여기에 유량 1을 흘려주고 다음으로  $s \to b \to a \to t$ 경로를 찾는다. 간선 $b \to a$의 용량은 0이고, 유량은 -1이므로 잔여 그래프를 통해 최대 1의 유량을 흘려줄 수 있다. 이 두번의 시행 후 그래프는 오른쪽과 같다. 이 방법대로 계속하면 최대 유량인 $99+99=198$번의 시행 후에야 최대 유량을 찾을 수 있다. 따라서 DFS로 증가 경로를 찾으면 시간 복잡도 $O(Ef)$ (E: 간선의 수, f: 최대 유량)이 된다. 

시간 복잡도가 큰 문제를 해결하기 위해선 DFS만 BFS로 바꾸면 된다. BFS로 증가 경로를 찾으면 시간 복잡도가 $O(VE^2)$로 단축되고, 에드몬드-카프 알고리즘이라 한다. 




# Reference
1. Maximum Flow: https://unorderedmap.tistory.com/6
2. Max-flow Min-cut: 공군 휴머니스트 air-wiki


https://everenew.tistory.com/177

https://m.blog.naver.com/jqkt15/222063980106
