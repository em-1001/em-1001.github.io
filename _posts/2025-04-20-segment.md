---
title:  "[Algorithm] Segment tree"
excerpt: "Segment tree"

categories:
  - Algorithm
tags:
  - Algorithm
last_modified_at: 2025-04-18T08:06:00-05:00
---

# Segment tree

세그먼트 트리는 보통 업데이트가 있는 구간 쿼리 문제에서 사용되는 알고리즘이다. 구간 쿼리 문제란 말 그대로 배열에서 특정 구간에 대해 질문하는 문제이다. 구간 쿼리 문제의 예시는 다음과 같다. 

배열 a가 주어졌을 때, 다음과 같은 구간 쿼리를 실행하여라.   
1 i j: i번째 원소 ~ j번째 원소의 합을 출력한다.   
2 i v: i번째 원소의 값을 v로 변경한다.  

만약 단순 배열로 위 문제를 해결한다고 하면 시간복잡도는 $O(N)$이 나온다. 하지만 세그먼트 트리를 이용한다면 쿼리의 수가 $Q$라 했을 때, $O((N+Q)logN)$에 해결이 가능하다. 

세그먼트 트리의 아이디어는 다음과 같다. 구간 쿼리 문제를 빠르게 해결하기 위해 모든 구간의 계산값을 미리 저장하는 대신 특정 구간만 미리 계산해두고 구간 쿼리가 들어왔을 때, 해당 구간에 맞게 이전에 계산 해둔 구간을 조합하는 것이다. 

<p align="center"><img src="https://github.com/user-attachments/assets/5d041311-967f-43c3-971f-4e298beffac4" height="" width=""></p>

세그먼트 트리는 위와 같이 배열을 절반씩 쪼개가면서 계산한 구간합을 트리의 형태로 저장한다. 만약 1 4 7이라는 쿼리가 들어온다면, 7 + sum(5,6) + 4 를 계산하면 된다. 

<p align="center"><img src="https://github.com/user-attachments/assets/7980ba44-669e-4042-906b-52e64a12c31f" height="" width=""></p>

2번 쿼리의 경우 2 3 6의 쿼리가 들어온다면, 배열의 3번째 값의 노드와 그 상위 노드들만 업데이트 해주면 된다. 이러한 방식으로 두 가지 쿼리를 모두 log시간에 해결할 수 있다. 

세그먼트 트리의 구현을 살펴보면, 우선 최초의 배열을 통해 세그먼트 트리를 초기화 하는 함수는 다음과 같다. 

```cpp
//arr은 입력받을 배열, tree는 구간합을 처리할 배열로 사이즈는 4*n이면 충분하다.
int tree[400001], arr[100001]; 

//node는 트리에서의 현재 노드의 인덱스. s,e는 arr에서 노드가 담당하는 부분의 좌측, 우측 끝 인덱스. 
int init(int node, int s, int e){
    if(s==e) return tree[node]=arr[s]; //leaf node 
    int m=s+e>>1;
    return tree[node]=init(node*2,s,m)+init(node*2+1,m+1,e);
}
```

초기화 시에는 `init(1,1,N)`으로 호출한다. 1번 쿼리의 구현은 다음과 같다. 

```cpp
int query(int node, int s, int e, int i, int j){
    if(s>j || e<i) return 0; //탐색 범위를 벗어나면 0리턴 
    if(s>=i && e<=j) return tree[node]; //탐색 범위에 포함되면 해당 노드의 값 리턴
    int m=s+e>>1; 
    return query(node*2,s,m,i,j)+query(node*2+1,m+1,e,i,j);
}
```

2번 업데이트 쿼리의 경우 다음과 같다. 

```cpp
int update(int node, int s, int e, int i, int v){
    if(i<s || i>e) return tree[node]; //탐색하는 범위에 포함되지 않는다면, 해당 노드의 값 리턴
    if(s==e) return tree[node]=v; //리프 노드라면 update 후 리턴
    int m=s+e>>1; 
    return update(node*2,s,m,i,v)+update(node*2+1,m+1,e,i,v); 
}
```




